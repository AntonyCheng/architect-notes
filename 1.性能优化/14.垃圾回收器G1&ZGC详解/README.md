# 垃圾回收器G1&ZGC详解

**说明**：本章节依然以Java 8为基准，描述Java 9中的G1垃圾回收器以及Java 11及其之后的ZGC垃圾回收器。说是详解，其实就是对这两种垃圾回收器做一个特性探讨，接下来内容大多数都是从以下参考收集而来：

- [深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）](../../1.性能优化/9.从JDK源码级别彻底剖析JVM类加载机制/JVM部分的参考资料/深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）周志明.pdf)
- [ZGC垃圾回收器参考资料](./ZGC垃圾回收器参考资料)
- [OpenJDK 23 Wiki](https://wiki.openjdk.org/display/zgc/Main#Main-JDK23)
- [新一代垃圾回收器ZGC的探索与实践](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)
- [Java Hotspot G1 GC的一些关键技术](https://tech.meituan.com/2016/09/23/g1.html)

**一般来说G1垃圾回收器和ZGC垃圾回收器使用默认的JVM参数即可，参数调整意义不大，还容易适得其反。**

## G1垃圾回收器

**JVM启用相关参数：`-XX:+UseG1GC`**

G1（Garbage-First）是一款面向服务器的垃圾回收器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。

在传统的CG垃圾回收器中都会将连续的内存空间划分为新生代、老年代以及元空间（Java 8之前是永久代），这种划分的特点是各代的存储地址是连续的，具体示例图如下所示：

![传统GC内存布局](./assets/8a9db36e.png)

但是从G1垃圾回收器开始就需要“忘记”这样连续的内存结构，因为在G1垃圾回收器中使用了**不连续的分代存储**地址，具体示例图如下所示：

![g1 GC内存布局](./assets/8ca16868.png)

G1垃圾回收器将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region。一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以用参数`-XX:G1HeapRegionSize`手动指定Region大小，但是推荐默认的计算方式。G1垃圾回收器保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是Region的集合。默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存，对应大概是100个Region，可以通过`-XX:G1NewSizePercent`设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过`-XX:G1MaxNewSizePercent`调整。年轻代中的Eden和Survivor对应的Region空间比例也跟之前一样，默认8:1:1，假设年轻代现在有1000个Region，Eden区对应800个，S0对应100个，S1对应100个。一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是说Region的区域功能可能会动态变化。

G1垃圾回收器对于对象什么时候会转移到老年代跟之前的垃圾回收器原则一样，唯一不同的是对大对象的处理在上图中可以注意到还有一些Region标明了H，它代表Humongous，表示这些Region存储的是大对象（Humongous Object，H-obj）。在G1垃圾回收器中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且一个大对象如果太大，可能会横跨多个Humongous Region来存放。Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老年代空间不够的GC开销。Full GC的时候除了回收年轻代和老年代之外，也会将Humongous区一并回收。

G1垃圾回收器的运作过程大致可划分为以下四个步骤，如图所示：

![image-20241210165117011](./assets/image-20241210165117011.png)

1、初始标记（Initial Marking，存在STW）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1垃圾回收器在这个阶段实际并没有额外的停顿。

2、并发标记（Concurrent Marking，存在STW）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象（和CMS垃圾回收器的并发标记类似）。

3、最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录（和CMS垃圾回收器的重新标记类似）。

4、筛选回收（Cleanup，存在STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间（可以用JVM参数`-XX:MaxGCPauseMillis`指定）来制定回收计划，比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region（Collection Set，要回收的集
合），尽量把GC导致的停顿时间控制在我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高回收效率。不管是年轻代或是老年代，回收算法主要用的是复制算法，将一个Region中的存活对象复制到另一个Region中，这种不会像CMS垃圾回收器那样回收完，因为有很多内存碎片还需要整理一次，G1垃圾回收器采用复制算法回收几乎不会有太多内存碎片。（注意：CMS垃圾回收器回收阶段是跟用户线程一起并发执行的，G1垃圾回收器因为内部实现太复杂暂时没实现并发回收，不过到了Shenandoah垃圾回收器实现了并发回收，Shenandoah垃圾回收器可以看成是G1垃圾回收器的升级版本，而G1垃圾回收器可以可以看成是CMS垃圾回收器的升级版本）。

G1垃圾回收器器在后台维护了一个优先列表，每次根据允许的回收时间，优先选择回收价值最大的Region（这也就是它的名字Garbage-First的由来），比如一个Region花200ms能回收10M垃圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面这个Region回收。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1垃圾回收器在有限时间内可以尽可能高的回收效率。

G1垃圾回收器被视为Java 7之后版本JVM的一个重要进化里程碑，它有如下特点：

1、并行与并发：G1垃圾回收器能充分利用CPU、多核环境下的硬件优势，使用多个CPU（或CPU核心）来缩短Stop-The-World停顿时间。部分其他垃圾回收器原本需要停顿Java线程来执行GC动作，G1垃圾回收器仍然可以通过并发的方式让Java程序继续执行。

2、分代回收：虽然G1垃圾回收器可以不需要其他垃圾回收器配合就能独立管理整个JVM堆内存，但是还是保留了分代的概念。

3、空间整合：与CMS垃圾回收器的“标记-清理”算法不同，G1垃圾回收器从整体来看是基于“标记-整理”算法实现的，但从局部上来看是基于“标记-复制”算法实现的。

4、可预测的停顿：这是G1垃圾回收器相对于CMS垃圾回收器的另一个大优势，降低停顿时间是两种垃圾回收器共同的关注点，但G1垃圾回收器除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段（通过参数`-XX:MaxGCPauseMillis`指定）内完成垃圾回收。

毫无疑问，可以由用户指定期望的停顿时间是G1垃圾回收器最突出的一个功能，设置不同的期望停顿时间，可使得G1垃圾回收器在不同应用场景中取得吞吐量和延迟之间的最佳平衡。不过这里设置的“期望值”必须是符合实际的，不能异想天开，毕竟G1垃圾回收器是要冻结用户线程来复制对象的，这个停顿时间再怎么低也得有个限度。它默认的停顿目标为200ms，一般来说， 回收阶段占到数十到一百甚至接近两百毫秒都很正常，但如果把停顿时间调得非常低，譬如设置为20ms，可能出现的结果就是由于停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，垃圾回收器回收的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积。很可能一开始回收器还能从空闲的堆内存中获得一些喘息的时间，但应用运行时间一长就不行了，最终引发Full GC反而降低性能，所以通常把期望停顿时间设置为100ms-300ms是比较合理的。

### G1垃圾回收方式分类

1、Minor GC：在G1垃圾回收器种，Minor GC并不是说现有的Eden区放满了就会马上触发，G1垃圾回收器会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数`-XX:MaxGCPauseMills`设定的值（默认200ms），那么就会增加年轻代的Region，继续给新对象存放，不会马上做Minor GC，直到下一次Eden区放满，G1计算回收时间接近参数`-XX:MaxGCPauseMills`设定的值（默认200ms），那么就会触发Minor GC。

2、Mixed GC：这不是Full GC，老年代的堆占有率达到参数`-XX:InitiatingHeapOccupancyPercent`设定的值则触发，回收所有的年轻代和部分老年代（根据期望的GC停顿时间确定老年代垃圾回收的优先顺序）以及大对象区，正常情况下，G1垃圾回收器是先做Mixed GC，主要使用“标记-复制”算法，需要把各个Region中存活的对象拷贝到别的Region里去，拷贝过程中如果发现没有足够的空闲Region能够承载拷贝对象，就会触发一次Full GC。

3、Full GC：停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region空间来供下一次Mixed GC使用，这个过程是非常耗时的（Shenandoah垃圾回收器优化成多线程回收）。

### G1垃圾回收器参数设置

`-XX:+UseG1GC`：使用G1垃圾回收器；

`-XX:ParallelGCThreads`：指定GC工作的线程数量；

`-XX:G1HeapRegionSize`：指定分区大小（1MB~32MB，且必须是2的N次幂），默认将整堆划分为2048个分区；

`-XX:MaxGCPauseMillis`：目标暂停时间（默认200ms）；

`-XX:G1NewSizePercent`：新生代内存初始空间（默认整堆5%）；

`-XX:G1MaxNewSizePercent`：新生代内存最大空间；

`-XX:TargetSurvivorRatio`：Survivor区的填充容量（默认50%），Survivor区域里的一批对象（年龄1+年龄2+年龄n的多个年龄对象）总和超过了Survivor区域的50%，此时就会把年龄n（含）以上的对象都放入老年代；

`-XX:MaxTenuringThreshold`：最大年龄阈值（默认15）；

`-XX:InitiatingHeapOccupancyPercent`：老年代占用空间达到整堆内存阈值（默认45%），则执行新生代和老年代的混合回收（Mixed GC），比如我们之前说的堆默认有2048个Region，如果有接近1000个Region都是老年代的Region，则可能就要触发Mixed GC了；

`-XX:G1MixedGCLiveThresholdPercent`（默认85%）：region中的存活对象低于这个值时才会回收该Region，如果超过这个值，存活对象过多，回收的的意义不大；

`-XX:G1MixedGCCountTarget`：在一次回收过程中指定做几次筛选回收（默认8次），在最后一个筛选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长；

`-XX:G1HeapWastePercent`（默认5%）：GC过程中空出来的Region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。

### G1垃圾回收器优化建议

假设参数`-XX:MaxGCPauseMills`设置的值很大，导致系统运行很久，年轻代可能都占用了堆内存的60%了，此时才触发年轻代GC。

那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。

或者是年轻代GC过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。

所以G1垃圾回收器优化核心还是在于调节`-XX:MaxGCPauseMills`这个参数的值，在保证年轻代GC别太频繁的同时，还得考虑每次GC过后的存活对象有多少，避免存活对象太多快速进入老年代，频繁触发Mixed GC。

### G1垃圾回收器适用场景

1、50%以上的堆被存活对象占用；

2、对象分配和晋升的速度变化非常大；

3、垃圾回收时间特别长，超过1秒；

4、8GB以上的堆内存（建议值）；

5、停顿时间是500ms以内。

### 每秒几十万并发的系统如何优化JVM

类似Kafka的高并发消息系统应该有所耳闻，对于Kafka来说，每秒处理几万甚至几十万消息时很正常的，一般来说部署Kafka需要用大内存机器（比如64G），也就是说可以给年轻代分配个三四十G的内存用来支撑高并发处理，这里就涉及到一个问题了，以前常说的对于Eden区的Minor GC是很快的，这种情况下它的执行还会很快吗？很显然不可能，因为内存太大，处理还是要花不少时间的，假设30-40G内存回收可能最快也要几秒钟，按Kafka这个并发量放满30-40G的Eden区可能也就一两分钟，那么意味着整个系统每运行一两分钟就会因为Minor GC卡顿几秒钟没法处理新消息，显然是不行的。那么对于这种情况如何优化了，这时就可以使用G1垃圾回收器，设置`-XX:MaxGCPauseMills`为50ms，假设50ms能够回收3-4G内存，然后50ms的卡顿其实完全能够接受，用户几乎是无感知的，那么整个系统就可以在卡顿几乎无感知的情况下一边处理业务一边回收垃圾。

G1垃圾回收器天生就适合这种大内存机器的JVM运行，可以比较完美的解决大内存垃圾回收时间过长的问题。

## ZGC垃圾回收器

**JVM启用相关参数：`-XX:+UseZGC`**

ZGC垃圾回收器是一款Java 11中新加入的具有实验性质的低延迟垃圾回收器，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector）垃圾回收器。

ZGC垃圾回收器目前平台支持如下：

| 平台            | 是否支持 | 起始版本                           | 备注                                                         |
| :-------------- | :------- | :--------------------------------- | :----------------------------------------------------------- |
| Linux/x64       | ✅        | JDK 15 (Experimental since JDK 11) |                                                              |
| Linux/AArch64   | ✅        | JDK 15 (Experimental since JDK 13) |                                                              |
| Linux/PowerPC   | ✅        | JDK 18                             |                                                              |
| macOS/x64       | ✅        | JDK 15 (Experimental since JDK 14) |                                                              |
| macOS/AArch64   | ✅        | JDK 17                             |                                                              |
| Windows/x64     | ✅        | JDK 15 (Experimental since JDK 14) | Requires Windows version 1803 (Windows 10 or Windows Server 2019) or later. |
| Windows/AArch64 | ✅        | JDK 16                             |                                                              |

ZGC垃圾回收器有如下三个目标（[ZGC-Joker-2021.pdf](./ZGC垃圾回收器参考资料/ZGC-Joker-2021.pdf)）：

![image-20241210231411363](./assets/image-20241210231411363.png)

1、最大GC停顿时间最终不超<1ms；

2、支持最大16TB量级的堆；

3、最大CPU开销不超过15%。

ZGC垃圾回收器没有传统意义上的分代概念，而是通过动态调整和并行处理来高效管理内存。对象被动态放置在不同的区域中，而垃圾回收则在这些区域中进行。

### ZGC垃圾回收器内存布局

ZGC垃圾回收器是一款基于Region内存布局的，使用了**读屏障、 颜色指针**等技术来实现可并发的“标记-整理”算法的， 以低延迟为首要目标的一款垃圾回收器，具体内存布局如下：

![image-20241210234606205](./assets/image-20241210234606205.png)

从上图可以看出ZGC垃圾回收器有大中小三类Region：

1、小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。

2、中型Region（Medium Region）： 容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。

3、大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。 每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC垃圾回收器的实现中是不会被重分配（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段，稍后会介绍到）的，因为复制一个大对象的代价非常高昂。
