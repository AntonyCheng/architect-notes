# InnoDB底层原理与MySQL日志机制深入剖析

## MySQL的内部组件结构

下面给出了MySQL中大致的内部组件结构，主要包括Server层以及引擎层两部分：

![image-20241118160414776](./assets/image-20241118160414776.png)

**Server层：**

该层主要包括连接器、查询缓存（可以忽略）、分析器、优化器以及执行器等。它们涵盖了MySQL的大多数核心服务功能，以及所有的内置函数（包括日期、时间、数学和加密等），所有存储引擎的公共功能都在这一层实现，比如存储过程、触发器以及视图等。**其实Server层中这些主要组件就是狭义上的MySQL组件**。

**引擎层：**

引擎层特指存储引擎，负责数据的存储和提取，其架构模式是插件式的，即可以随时更换，支持InnoDB、MyISAM、Memory等多种存储引擎。现在最常用的存储引擎就是InnoDB，从MySQL 5.5版本开始成为MySQL的默认存储引擎。

接下来就针对Server层中五个组件进行具体描述。

### 连接器

众所周知，Navicat、JDBC等一众MySQL客户端都需要先和MySQL建立通信连接才能进行数据交互，而连接器主要负责的就是建立客户端与MySQL之间的连接。通过下面这条SQL语句就能够建立TCP连接并且认证你的身份和权限：

```shell
mysql -h host -P port -u root -p password
```

如果用户名或者密码不对，就会收到"Access denied for user"的错误提示，随后结束程序；

如果用户名和密码认证通过之后，连接器就会在权限表中查询登录用户所拥有的权限。之后，该连接中的权限判断逻辑都会依赖于此时读取到的权限数据。这就意味着一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

### 查询缓存（可忽略）

先说明，**目前用得最多的MySQL 8已经弃用了查询缓存，而MySQL 5在绝大多数场景下也不会用到查询缓存**。下面都是基于MySQL 5进行的讨论。

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。

如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。

但是**大多数情况下这个查询缓存就是一个鸡肋**，原因是查询缓存的失效非常频繁，只要对数据库中任何一个表进行了更新，这个表中的所有查询缓存都会被清空，对于更新压力大的业务场景来说，查询缓存的命中率会非常低。但是MySQL也提供了一种按需使用的查询方式，前提是要在MySQL配置文件my.cnf中将query_cache_type参数设置成DEMAND：

```properties
#query_cache_type有3个值 0代表关闭查询缓存OFF，1代表开启ON，2（DEMAND）代表当SQL语句中有SQL_CACHE关键词时才缓存
query_cache_type=2
```

这样对于默认的查询SQL语句都不会使用查询缓存，而对于用户确定需要查询缓存的语句，可以使用SQL_CACHE显式进行指定：

```sql
SELECT SQL_CACHE * FROM text WHERE id = 5;
```

如果想要查看当前MySQL是否开启了查询缓存机制，执行以下查询语句：

```sql
SHOW GLOBAL VARIABLES LIKE "%query_cache_type%";
```

**一定一定要记住，MySQL 8中已经移除了查询缓存功能！**

### 分析器

如果没有开启查询缓存或者没有命中查询缓存，那么就会真正执行语句，分析器首先会做词法分析，即MySQL需要识别出一条SQL语句中的字符串分别是什么，代表什么，比如把"SELECT"识别为关键字，把"id"识别成列ID等。

词法分析之后就要接着做语法分析，根据词法分析的结果和语法规则判断输入的这条SQL语句是否满足MySQL语法，如果语法不对，那就会收到"You have an error in your SQL syntax"的错误提醒。

下面用一张图片来完整描述分析器对SQL语句的分析过程：

![image-20241118221615391](./assets/image-20241118221615391.png)

其中分析机会把SQL语句拆分成一颗AstTree，即语法树，具体大致如下图：

![image-20241118221711624](./assets/image-20241118221711624.png)

至此分析器的工作也基本完成了，接下来会进入优化器。

### 优化器

其实优化器的优化阶段在[MySQL索引优化实战（1）](../3.MySQL索引优化实战（1）/README.md)章节内容中已经讨论过了，具体使用trace工具类对一条SQL语句详情进行展示。优化阶段主要就是让MySQL知道这条SQL语句要做什么？怎么做？特别是表中存在多个索引时，优化阶段需要计算每个索引生效所要付出的代价（cost）来决定使用哪个索引；或者在一条SQL语句中有多表联查时，决定各个表之间的连接顺序；以及MySQL内部的一些优化机制。

### 执行器

在开始执行的时候，需要先判断一下当前用户对这个表是否有执行的权限，如果没有就会返回没有权限的提示，如果有权限就会打开表继续执行，具体一些就是根据表的引擎定义去底层使用当前引擎所提供的接口。

## InnoDB底层原理和MySQL日志机制

